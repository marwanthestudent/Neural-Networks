# -*- coding: utf-8 -*-
"""numpy_examples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19gNj65aGrl2qYIgInQAJNXVO6jwiRtTL
"""

import numpy as np

array_1d = np.array([10, 5, 2, 4])
print("array_1d:", array_1d)
print("array_1d data_type:", array_1d.dtype)
print("array_1d shape:", array_1d.shape)

array_2d = np.array([[1,2,3], [4,5,6]], dtype='float')
print("array_2d:\n", array_2d, "\n")
print("array_2d data_type:", array_2d.dtype)
print("array_2d shape:", array_2d.shape)

# Convenient way to create an "empty" numpy array of a specific shape.
# Of course, it is not really "empty", it is filled with zeros.
array_2d = np.zeros((3,4)) 
print("array_2d:\n", array_2d, "\n")
print("array_2d data_type:", array_2d.dtype)
print("array_2d shape:", array_2d.shape)

# creating a 2D array of random values uniformly distributed between 0 and 1
(rows, cols) = (3, 4)
random_values = np.random.rand(rows, cols)
print("random_values:\n", random_values, "\n")
print("random_values data_type:", random_values.dtype)
print("random_values shape:", random_values.shape)

# If you want to format the way a numpy array is printed, use 
# numpy.set_printoptions. There are a lot of options, see documentation.
# Here, we specify to use four decimal digits.
np.set_printoptions(precision = 4)
print("random_values*200:\n", random_values*200, "\n")

# Here we specify to print each value using the printf-like "%9.f" format,
# i.e., 9 spaces minimum, 4 decimal digits.
np.set_printoptions(formatter={'all':lambda x: "%9.4f" % (x)})
print("random_values*200:\n", random_values*200, "\n")


# Computing mean and standard deviation of values in a matrix.
# Notice use of "printf-style" formatting of output.
print("random_values mean value = %.4f, std = %.4f" %
      (np.mean(random_values), np.std(random_values)))


# You can do many operations along a specific dimension
# For example, here we compute the mean of every row in the matrix.
row_means = np.mean(random_values, 1)
print("row means:", row_means)

# And here we compute the mean of every column in the matrix.
col_means = np.mean(random_values, 0)
print("col means:", col_means)

# examples of matrix operations:
a = np.array([[2.1, 3.2], [1.6, 5.3]])
print("a:\n", a, "\n")

# Computing the inverse of matrix a.
# Use np.linalg.pinv, and NOT np.linalg.inv, the pinv function (pseudoinvese)
# is significantly more relabile (numerically stable)
inv_a = np.linalg.pinv(a)
print("inverse of a:\n", inv_a, "\n")

# Regrettably (for me), a * b in numpy does element-wise multiplication,
# and NOT matrix multiplication.
r1 = a*inv_a
print("r1:\n", r1, "\n")

# Use np.dot for matrix multiplication.
r2 = np.dot(a, inv_a)
print("r2:\n", r2, "\n")

# Example of computing the transpose of a matrix.
at = a.transpose()
print("a transpose:\n", at, "\n")

